const u=r=>r&&{}.toString.call(r)==="[object Function]",c=r=>{const[n,o]=r.split(" ");if(!n||!o)return"00:00";let[t,e]=n.split(":");return!t||!e?"00:00":(t==="12"&&(t="00"),o.toUpperCase()==="PM"&&(t=(parseInt(t,10)+12).toString()),`${t.padStart(2,"0")}:${e.padStart(2,"0")}`)},f=r=>{const[n,o]=r.split(":"),t=parseInt(n??"0",10),e=parseInt(o??"0",10),a=t>=12?"PM":"AM";return`${(t%12||12).toString().padStart(2,"0")}:${e.toString().padStart(2,"0")} ${a}`},l=r=>/^(0[1-9]|1[0-2]):([0-5][0-9])(?:\s?(AM|PM))?$/i.test(r),s={B:1,KB:1024,MB:1048576,GB:1073741824};function m(r){const n=r.match(/^(\d+(?:\.\d+)?)\s*(B|KB|MB|GB)$/i);if(!n)throw new Error(`Invalid storage value format: ${r}`);const[,o,t]=n;if(!o||!t)throw new Error(`Invalid storage value format: ${r}`);return{normalizedValue:parseFloat(o)*(s[t.toUpperCase()]||1),unit:t.toUpperCase(),value:parseFloat(o)}}function p(r){const n=["GB","MB","KB","B"];for(const o of n){const t=s[o];if(t===void 0)throw new Error(`Missing factor for unit: ${o}`);if(r>=t||o==="B"){const e=r/t;return`${e%1===0?`${e.toFixed(0)}`:`${e.toFixed(2)}`} ${o}`}}return`${r} B`}export{c as a,l as b,f as c,p as f,u as i,m as n};
